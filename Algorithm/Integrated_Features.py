# -*- coding: utf-8 -*-
""" Integrated Features

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jJnMCh1aUgUyKvCK5ouKOC5gOh4kMHEV
"""

!pip install shapely
!pip install geopandas
!pip install osmapi

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from shapely.geometry import Point
import geopandas as gpd
import plotly.graph_objects as go
import plotly.express as px

def speed_violation(speed,GpsTime, df):
    """ To find the regions where the speed limit is exceeded """
    SPEED_VIOLATION = []
    GPS_TIME = []
    LONGITUDE_DATA = [] 
    LATITUDE_DATA = []
    SPEED = []

    for i in df.index:
        if speed[i]== '-' :
            speed[i]= '0';
  
    for i in df.index:
      if (float(speed[i])>20):
        SPEED_VIOLATION.append([df[' Latitude'][i],df[' Longitude'][i]])
        #SPEED_VIOLATION.append(speed[i])
        GPS_TIME.append(GpsTime[i])
        LONGITUDE_DATA.append(Longitude[i])
        LATITUDE_DATA.append(Latitude[i])
        #print(df["Speed (GPS)(km/h)"][i])

    VIOLATION = pd.DataFrame(data=SPEED_VIOLATION, columns=['Latitude', 'Longitude'])
    return VIOLATION

def coolant(coolant_temperature,engine_load,trip_time):
    a = []
    b = []
    x = []
    coolant_temperature = coolant_temperature.astype(float)
    for i in range(0, len(coolant_temperature)):
        coolant_temperature[i] = (coolant_temperature[i]*9/5) +32
        b.append(coolant_temperature[i])
    for i in range(0, len(engine_load)):
        engine_load[i] = (float(engine_load[i]))
    for i in range(0, len(trip_time)):
        trip_time[i] = (int(trip_time[i]))
        a.append(trip_time[i])
    engine_load_threshold = 0.50*max(engine_load)
    trip_time_threshold = 0.50*max(trip_time)
    safestate = 0
    lowesttemp = 0.0
    normaltemp = 190.0 #Reference form internet safe state 190F to 220F
    highesttemp = 220.0
    for i in range(0, len(coolant_temperature)):
        if coolant_temperature[i] > normaltemp and coolant_temperature[i] < highesttemp:
            if trip_time[i] < trip_time_threshold:
                if engine_load[i] < engine_load_threshold:
                    safestate += 1
        elif coolant_temperature[i] < normaltemp and coolant_temperature[i] > lowesttemp:
            safestate += 1
        elif coolant_temperature[i] > highesttemp:
            safestate -= 1
    if safestate > 400:
        print("Engine is in safe state")
    else:
        print("Engine is in danger state")
    plt.plot(a, b, "r")
    plt.xlabel("Trip Time")
    plt.ylabel("Coolant Temperature")
    plt.title("Engine Coolant Temperature Management")
    plt.show()

def distavg(dist,fuel,kmpl):
    final = dist.iloc[-1]
    final = float(final)
    print("The total distance covered:", final)
    rem_fuel = fuel.iloc[-1]
    rem_fuel = float(rem_fuel)
    used = 100 - rem_fuel
    used = used/100
    print("fuel used:", used)
    for i in range(len(kmpl)):
        kmpl[i] = float(kmpl[i])
    x = kmpl.mean()
    print("kpl avg:", x)
    x = x*used
    print("exp distance", x)
    diff = x-final
    print(diff)

def loadanalysis(engine_load,engine_rpm,Vehicle_speed):
    Gear_Ratio = 1.5
    AXLE_RATIO = 4
    TYRE_SIZE = 12
    EXPT_SPEED = []
    OVERLOAD_COUNTER = 0
    
    for i in range(0, len(engine_load)):
        engine_load[i] = float(engine_load[i])

    for j in range(0, len(engine_rpm)):
        engine_rpm[j] = float(engine_rpm[j])
        
    for k in range(0, len(Vehicle_speed)):
        Vehicle_speed[k] = float(Vehicle_speed[k])
        #ACTUAL SPEED = (ENGINE RPM * PERIMETER OF TYRE)/(AXLE RATIO * GEAR RATIO)
    for l in range(0,len(engine_load)):
        EXPT_SPEED = (engine_rpm[l] *60*3.14*2 *TYRE_SIZE*25.4*0.000001)/(Gear_Ratio*AXLE_RATIO)
        if(Vehicle_speed[l]<(0.4*EXPT_SPEED)):  # Checking whether vehicle speed is less than expected speed
            OVERLOAD_COUNTER = OVERLOAD_COUNTER + 1
        
    maxinload = 0
    for i in range(len(engine_load)):
        if maxinload < engine_load[i]:
            maxinload = engine_load[i]
            load_threshold = 0.5 * maxinload
    maxinrpm = 0
    for j in range(len(engine_rpm)):
        if maxinrpm < engine_rpm[j]:
            maxinrpm = engine_rpm[j]

    rpm_threshold = 0.5 * maxinrpm
    counter_overload = 0
    for i in range(len(engine_rpm)):
        if engine_load[i] > load_threshold and  engine_rpm[i] > rpm_threshold:
            counter_overload = counter_overload + 1 # Checking whether engine load and engine rpm are less than threshold

    if counter_overload < 150 or OVERLOAD_COUNTER < 150:
        print("Load is correct")
    else:
        print("Overload")

coolant_temperature = df['Engine Coolant Temperature(Â°C)'].replace(to_replace="-", value="0")
engine_load = df['Engine Load(%)'].replace(to_replace="-", value="0")
trip_time = df['Trip Time(Since journey start)(s)'].replace(to_replace="-", value="0")
dist = df['Trip Distance(km)']
fuel = df['Fuel Remaining (Calculated from vehicle profile)(%)']
kmpl = df["Kilometers Per Litre(Instant)(kpl)"].replace(to_replace='-', value='0')
engine_rpm = df["Engine RPM(rpm)"].replace(to_replace="-", value="0")
Vehicle_speed = df["Speed (GPS)(km/h)"].replace(to_replace="-",value = "0")
loadanalysis(engine_load,engine_rpm,Vehicle_speed)
distavg(dist,fuel,kmpl)        
coolant(coolant_temperature,engine_load,trip_time)

import osmapi

def traffic(SPEED,GPS):
  SPEED_ARR = np.array(SPEED)
  GPS_ARR = np.array(GPS)
  A = len(SPEED)
  for i in range(0, A):
      SPEED_ARR[i] = float(SPEED_ARR[i])
  LOW_CONGESTION_COUNT = 0
  MODERATE_CONGESTION_COUNT = 0
  HIGH_CONGESTION_COUNT = 0

  LOW_CONGESTION_LOC = []
  MODERATE_CONGESTION_LOC = []
  HIGH_CONGESTION_LOC = []

  for i in range(0, A):
      if SPEED_ARR[i] < 10.00:
          HIGH_CONGESTION_COUNT += 1
          HIGH_CONGESTION_LOC.append(GPS_ARR[i])
      elif SPEED_ARR[i] > 10.00 and SPEED_ARR[i] < 20.00:
          MODERATE_CONGESTION_COUNT += 1
          MODERATE_CONGESTION_LOC.append(GPS_ARR[i])
      elif SPEED_ARR[i] > 20.00:
          LOW_CONGESTION_COUNT += 1
          LOW_CONGESTION_LOC.append(GPS_ARR[i])

  print("No. Of High Congestion Areas:%.2f"%HIGH_CONGESTION_COUNT)
  print("No. Of Moderate Congestion Areas:%.2f"%MODERATE_CONGESTION_COUNT)
  print("No. Of Low Congestion Areas:%.2f"%LOW_CONGESTION_COUNT)
  print()

  api = osmapi.OsmApi()
  print(api.NodeGet(123))
  api = osmapi.OsmApi(api="https://api06.dev.openstreetmap.org", username="manojmadhavk", password="openstreet123")
  api.ChangesetCreate({u"comment": u"Traffic Congestion"})

  for i in range(len(LOW_CONGESTION_LOC)):
      print(api.NodeCreate({u"lon":LOW_CONGESTION_LOC[i][0], u"lat":LOW_CONGESTION_LOC[i][1], u"LCA": {}}))

  for i in range(len(MODERATE_CONGESTION_LOC)):
      print(api.NodeCreate({u"lon":MODERATE_CONGESTION_LOC[i][0], u"lat":MODERATE_CONGESTION_LOC[i][1], u"MCA": {}}))

  for i in range(len(HIGH_CONGESTION_LOC)):
      print(api.NodeCreate({u"lon":HIGH_CONGESTION_LOC[i][0], u"lat":HIGH_CONGESTION_LOC[i][1], u"HCA": {}}))
  api.ChangesetClose()
  print()
SPEED = df["Average trip speed(whilst moving only)(km/h)"].replace(to_replace="-", value="0")
GPS = pd.DataFrame(df, columns=[" Longitude", " Latitude"])
traffic(SPEED,GPS)

!pip install osmapi

def lean(x):
  df['O2 Volts Bank 1 sensor 2(V)'] = df['O2 Volts Bank 1 sensor 2(V)'].astype(float)
  DF1 = df[(df['O2 Volts Bank 1 sensor 2(V)'] >= 0.0) & (df['O2 Volts Bank 1 sensor 2(V)'] <= 0.1)]
  print('The number of instances of NOx emissions is:', DF1['O2 Volts Bank 1 sensor 2(V)'].count())

def rich(x):
  df['O2 Volts Bank 1 sensor 2(V)'] = df['O2 Volts Bank 1 sensor 2(V)'].astype(float)
  DF2 = df[(df['O2 Volts Bank 1 sensor 2(V)'] >= 0.9) & (df['O2 Volts Bank 1 sensor 2(V)'] <= 1.0)]
  print('The number of instances of CO and HC emissions is:', DF2['O2 Volts Bank 1 sensor 2(V)'].count())

x= 'O2 Volts Bank 1 sensor 2(V)'
lean(x)
rich(x)

def plot_title_label_legend(title, xlabel, ylabel, legend):
    """ This function will help in labeling a graph with x and y labels,
        also it will give it a title and a legend """
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.legend(legend)


def geofencing(df):

  df.columns = df.columns.str.strip()

  #Creating a geometry column for a Geo Pandas DataFrame
  GEOMETRY_GDF = [Point(xy) for xy in zip(df['Longitude'], df['Latitude'])]

  #Coordinate reference system : WGS84
  CRS_GDF = {'init': 'epsg:4326'}

  #Creating a Geographic data frame(This is useful to plot Latitude Longitude vales)
  DF_GDF = gpd.GeoDataFrame(df[['GPS Time', 'Device Time', 'Longitude', 'Latitude']],\
                             crs=CRS_GDF, geometry=GEOMETRY_GDF)

  #plotting the Lat-Long points
  DF_GDF.plot(marker='o', color='b', markersize=0.5)

  
  #Taking inputs from the user to choose the point from which geofencing has to be done
  IDX1 = int(input("which point do you want to use as the midpoint? "))
  P1 = DF_GDF.loc[IDX1, 'geometry']

  #Taking inputs for the buffer size of the geofence boundary
  BFR_RAD = float(input("What do you want the buffer radius as? (Use values between 0.001-0.09):  "))
  BOUNDARY_CIRCLE = P1.buffer(BFR_RAD)

  
  #plotting the boundary circle around the latitude Longitude values of the vehicle
  X_VAL, Y_VAL = BOUNDARY_CIRCLE.exterior.xy
  plt.plot(X_VAL, Y_VAL)
  plt.plot(df.loc[:, 'Longitude'], df.loc[:, 'Latitude'], '.')
  plt.plot(df.loc[IDX1, 'Longitude'], df.loc[IDX1, 'Latitude'], 'r*')

  plot_title_label_legend('Latitude vs Longitude with a boundary circle before Geofencing', 'Longitude---->',\
                        'Latitude---->', ["Locations of the vehicle", "Boundary of the Geofence", "Point selected"])  
  

  #Asking the user to select appropriate Lat-Long values to be evaluated in the
  #Geofencing algorithm

  CMP_VAR = input("Do you want to compare all values in the dataset? Y/N ")
  if CMP_VAR.lower() == 'y':
      IDX2 = len(DF_GDF.index)-1
      P2 = DF_GDF.loc[:IDX2, 'geometry'].values
  elif CMP_VAR.lower() == 'n':
      CMP_VAR2 = input("Do you want to compare for a range of values in the dataset? Y/N ")
      if CMP_VAR2.lower() == 'y':
          IDX2_MIN, IDX2_MAX = input("Enter the min and max value: ").split(' ')
          P2 = DF_GDF.loc[int(IDX2_MIN) : int(IDX2_MAX), 'geometry'].values
      else:
          IDX2 = int(input("Enter the index of the point you want to verify? "))
          P2 = DF_GDF.loc[IDX2, 'geometry']

  #Initializing an empty list to store the output co-ordinates
  MASTER_LIST_GEO = []

  #Evaluating if a particular point/ particular points is/are inside the boundary or not

  if CMP_VAR.lower() == 'y':
      ID = 0
      for pt in P2:
          MASTER_LIST_GEO.append([ID, pt, BOUNDARY_CIRCLE.contains(pt)])
          ID += 1
  elif CMP_VAR2.lower() == 'y':
      ID = int(IDX2_MIN)
      for pt in P2:
          MASTER_LIST_GEO.append([ID, pt, BOUNDARY_CIRCLE.contains(pt)])
          ID += 1
  else:
      MASTER_LIST_GEO.append([IDX2, P2, BOUNDARY_CIRCLE.contains(P2)])

  #Finding the index values of the Points inside and outside the boundary
  TRUE_VAL = [i[0] for i in MASTER_LIST_GEO if i[2] == True]
  FALSE_VAL = [i[0] for i in MASTER_LIST_GEO if i[2] == False]

  #plotting the locations of the vehicle inside the boundary and outside the boundary
  plt.plot(df.loc[TRUE_VAL, 'Longitude'], df.loc[TRUE_VAL, 'Latitude'], 'g.', markersize=3)

  plt.plot(df.loc[FALSE_VAL, 'Longitude'], df.loc[FALSE_VAL, 'Latitude'], 'r.', markersize=3)

  plt.plot(X_VAL, Y_VAL)
  plt.plot(df.loc[IDX1, 'Longitude'], df.loc[IDX1, 'Latitude'], 'b*')

  plot_title_label_legend('Latitude vs Longitude after Geofencing', 'Longitude---->',\
                          'Latitude---->', \
                           ["Locations of the vehicle outside Geofence", \
                           "Locations of the vehicle inside Geofence", "Boundary of the Geofence", "Point Selected"])
  plt.show()

geofencing(df)

def find_potholes(accln, obd_df):
    """ Function to Find potholes"""
    potholes = []
    length = len(accln)
    time_range = range(0, length)
    plt.plot(time_range, accln)
    plt.xlabel('time in seconds')
    plt.ylabel('Acceleration due to gravity (in g)')
    plt.show()
    for i in range(1, length-1):
        if isinstance(accln[i], float) and isinstance(accln[i-1], float) and isinstance(accln[i+1], float):
            if accln[i] < accln[i-1] and accln[i] < accln[i+1]:
                potholes.append([obd_df[' Latitude'][i],
                                 obd_df[' Longitude'][i],
                                 (accln[i+1]-accln[i])])
    pothole = pd.DataFrame(data=potholes, columns=['Latitude', 'Longitude', 'Pothole_Gradient'])
    return pothole

ACCELZ = df["Acceleration Sensor(Z axis)(g)"]
POTHOLE = find_potholes(ACCELZ, df)
HIGHEST_THRESHOLD_POTHOLE = max(POTHOLE['Pothole_Gradient'])
MIDDLE_THRESHOLD_POTHOLE = (2/3)*max(POTHOLE['Pothole_Gradient'])
LOWER_THRESHOLD_POTHOLE = (1/3)*max(POTHOLE['Pothole_Gradient'])
LOW_PRIORITY = []
MID_PRIORITY = []
HIGH_PRIORITY = []
for ind in POTHOLE.index:
    if POTHOLE['Pothole_Gradient'][ind] <= LOWER_THRESHOLD_POTHOLE:
        LOW_PRIORITY.append([POTHOLE['Latitude'][ind],
                             POTHOLE['Longitude'][ind],
                             POTHOLE['Pothole_Gradient'][ind]])
    elif POTHOLE['Pothole_Gradient'][ind] > LOWER_THRESHOLD_POTHOLE and POTHOLE['Pothole_Gradient'][ind] <= MIDDLE_THRESHOLD_POTHOLE:
        MID_PRIORITY.append([POTHOLE['Latitude'][ind],
                             POTHOLE['Longitude'][ind],
                             POTHOLE['Pothole_Gradient'][ind]])
    else:
        HIGH_PRIORITY.append([POTHOLE['Latitude'][ind],
                              POTHOLE['Longitude'][ind],
                              POTHOLE['Pothole_Gradient'][ind]])
LOW_PRIORITY = pd.DataFrame(data=LOW_PRIORITY, columns=['Latitude', 'Longitude', 'Intensity'])
MID_PRIORITY = pd.DataFrame(data=MID_PRIORITY, columns=['Latitude', 'Longitude', 'Intensity'])
HIGH_PRIORITY = pd.DataFrame(data=HIGH_PRIORITY, columns=['Latitude', 'Longitude', 'Intensity'])
plt.scatter(LOW_PRIORITY['Longitude'], LOW_PRIORITY['Latitude'], label='low priority pothole')
plt.scatter(MID_PRIORITY['Longitude'], MID_PRIORITY['Latitude'], label='Mid priority Pothole')
plt.scatter(HIGH_PRIORITY['Longitude'], HIGH_PRIORITY['Latitude'], label='High priority Pothole')
plt.xlabel('Latitude')
plt.ylabel('Longitude')
plt.title('Pothole Analysis and plotting')
plt.legend()
plt.show()
FIG2 = px.scatter_mapbox(LOW_PRIORITY, lat="Latitude", lon="Longitude")
FIG2.add_trace(go.Scattermapbox(
        lat=MID_PRIORITY['Latitude'],
        lon=MID_PRIORITY['Longitude'],
        name='medium priority potholes',
        mode='markers',
        marker=go.scattermapbox.Marker(
            size=17,
            color='rgb(255, 113, 181)',
            opacity=0.7
        ),
    ))
FIG2.add_trace(go.Scattermapbox(
        lat=HIGH_PRIORITY['Latitude'],
        lon=HIGH_PRIORITY['Longitude'],
        name='high priority potholes',
        mode='markers',
        marker=go.scattermapbox.Marker(
            size=17,
            color='rgb(255, 0, 0)',
            opacity=0.7
        ),
    ))
FIG2.update_layout(mapbox_style="open-street-map")
FIG2.update_layout(margin={"r":0, "t":0, "l":0, "b":0})
FIG2.show()
import os

df = pd.read_excel("sample_data/trackLog-2020-Jan-02_16-22-5858.xlsx")
Longitude=df[" Longitude"]
Latitude=df[" Latitude"]
speed=df["Speed (GPS)(km/h)"]
GpsTime=df["GPS Time"]
Speed_violate=speed_violation(speed,GpsTime,df)

plt.plot(Speed_violate.loc[:, 'Longitude'], Speed_violate.loc[:, 'Latitude'], 'r.')
print(speed)
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Speed Violation')
plt.legend()
plt.show()